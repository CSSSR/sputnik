## Лучшие практики
### Строгая типизация
Язык Javascript не имеет строгой типизации, поэтому в больших проектах, для того чтобы избавиться от неочевидных преобразований данных, используют такие статические анализаторы, как свежий [Flow](http://flowtype.org) от Facebook и проверенный [TypeScript](https://www.typescriptlang.org/) от Microsoft. Можно считать, что это отдельный язык, но после компиляции все элементы строгой типизации убираются из кода. Данные системы позволяют ускорять рефакторинг, так как на любом этапе вы и ваш редактор знаете структуру и типы всех данных, поэтому переименование, преобразование переменных и функций, а также основные виды рефакторинга, становятся более безопасными.

Практика показывает, что использование строгой типизации и подобных систем ускоряет разработку, в связи с тем, что вы реже компилируете и запускаете код, чтобы найти те ошибки, которые эти системы отображают по мере набора кода прямо в редакторе. Многие недооценивают те 5-30 секунд, которые требуются для запуска проекта и сколько [мозготоплива](http://blog.micromiles.co/%D0%BC%D1%8B%D1%81%D0%BB%D0%B5%D1%82%D0%BE%D0%BF%D0%BB%D0%B8%D0%B2%D0%BE-%D1%81%D0%B8%D0%BB%D0%B0-%D0%B2%D0%BE%D0%BB%D0%B8-%D1%81%D0%B0%D0%BC%D0%BE%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C) сгорает за это время.

Пример написания функции в Flow:
```javascript
/* @flow */
const multiply = (x: number): number => x * 2;
```
При использовании функции таким образом:
```javascript
/* @flow */
multiply('this is string')
```
будет показана ошибка с указанием несовместимых типов.

При строгой типизации, структуры данных, такие как объекты, описываются как интерфейсы, могут храниться в отдельных файлах и вам нет необходимости описывать их каждый раз, достаточно указать название интерфейса.

При использовании Flow, типизация пишется один раз и не требует propTypes в классах компонентов React.

### Модульная архитектура
Разбивайте большое приложение на максимально изолированные модули. По "правилу треугольника" между/над ними будет общий модуль, который обеспечит связь между ними. Сами модули не должны общаться между собой напрямую. Весь общий код лучше размещать в общем модуле. При правильном разбиении, вы сможете делать приложение для браузера, сервера и мобильных устройств не используя "копи-паст" между ними.

### Уменьшение сложности complexity index
В js любая функция является объектом и может быть внутри объекта, поэтому вы можете уменьшать сложность каждой из них, избавляясь от лишних "if", "&&", "||", пример:
```javascript
const keyPress = (keyCode) => {
 if(keyCode === 'Enter') {
   console.log('Enter')
 } else if (keyCode === 'Space') {
   console.log('Space')
 }
}
// лучше, так как добавлять новые клавиши, если их много, легче и можно переиспользовать функции:
const keyPress = (keyCode) => {
 const fn = {
   'Enter': () => console.log('Enter'),
   'Space': () => console.log('Space')
 }
 if(typeof fn[keyCode] === 'function') {
   fn[keyCode]()
 }
}
```

### Антипаттерны 

#### Не доверяйте окружению
Предположим, вы надеетесь, что у вас есть объект window и используете его функции, но вы не учитываете, что код может выполняться на стороне сервера, где такого объекта нет. Или же вы модифицируете dom в зависимости от версии браузера, которую определяете из window. В результате вы получите факт того, что сервер отрендерит одно, а браузер - другое, что, например, в React выдаст предупреждение бесполезности [изоморфного рендера](https://habrahabr.ru/post/264423/).

#### Функция/компонент должны делать одну функцию и делать её хорошо (основной принцип Linux)
Старайтесь всё разбивать на функции и компоненты, выполняющие лишь одну задачу. Это связано с законом композиции сложных проектов, который обеспечивает переиспользование. Пример: приложение будет состоять из 100 маленьких функций, которые переиспользуются, или из 500 функций, выполняющих по нескольку задач, поэтому их переиспользование затруднено или внутри будет множество условий "if". Функции/компоненты, которые вы пишите, не должны знать того, без чего они могут обойтись. На примере компонента, рассмотрите два варианта:

1) Вы вставили padding внутрь компонента. В одной форме он нужен, в другой не нужен, в третьей нужен разный padding по сторонам, все эти варианты вы будете указывать явно или ставить условия "if". Если эти условия внутри компонента изменит другой разработчик, то у вас "расползётся" неизвестная ему форма. Во всех остальных компонентах вы будете придерживаться подобного подхода и будете "копипастить" код, связанный с padding, в том числе использовать файлы стилей там, где компонент мог бы обходиться без стилей. В памяти приложения (и разработчика) этот "копипаст" занимает место.

2) У вас отдельный компонент для установки padding, вы его используете там, где он нужен, с разными другими компонентами. Он один на всё приложение. Осознать его использование легко, код чистый и компактный. По использованию памяти этот вариант тоже оптимальный.

Пример выше можно дополнить использованием Алфавита, так как каждая буква выполняет одну функцию, текст занимает оптимальное место и легко читается. А если появилось бы дополнительное условие, что букву "б" можно использовать только в словах с 5 буквами, а иначе вместо неё нужно использовать "б(8)", то появилась бы излишняя сложность. Тоже самое относится к любой составляющей большого проекта. Старайтесь использовать этот принцип при создании отдельных функций, отдельных компонентов, отдельных файлов, отдельных модулей, отдельных программ и инструментов.

Также данный подход позволит использовать общий код для приложений браузера, сервера или мобильных устройств(например React native)

#### Хранение вычисляемых значений
Старайтесь не сохранять в объектах то, что можно вычислить на основе имеющихся данных, в связи с тем, что данные необходимо "[нормализовывать](https://ru.wikipedia.org/wiki/%D0%9D%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0)". Это обеспечивает оптимальное использование памяти, код становится более читаемым, так как вам не нужно инвалидировать это "кэшированное" значение, которое можно вычислить. Не бойтесь переносить это вычисляемое значение в функции и выполнять их многократно. Для оптимизации, вы можете просто добавить в эту функцию мемоизацию(кеширование результата функции на основании полного(указанного) набора аргументов, без лишнего кода, например [memoizee](https://www.npmjs.com/package/memoizee)). Также, нормализация данных, функций и компонентов, тесно перекликается с предыдущим пунктом и обеспечивает более компактный код.

#### Наследование и композиция (правило "треугольника")
В Js чаще используется композиция, чем наследование. Композиция - это когда вы пишете функцию в отдельном файле(месте кода) и используете её там, где нужно. Наследование - это когда у предка свои функции, а у его наследников - свои, но наследник может пользоваться и функциями предка. Принцип "треугольника" стоит вспомнить, когда вы не можете определить "куда писать код". Если этот код будет использоваться несколькими потомками, размещаете код у предка. Если функция уникальная, размещайте её у потомка, который её использует.

Иногда это применяется не только для наследования, но и при создании файлов кода проекта. У вас есть общие компоненты, вы их размещаете в отдельной папке, а то, что уникально, размещаете вместе с модулем конкретного раздела или страницы сайта. Тоже самое с файлами функций - если функция используется один раз, вы её размещаете в папке с кодом, который её использует, если она используется многократно, то переносите в общую папку (например utils или helpers).

#### Лапша-код
Любая ваша сущность должна быть оптимально компактна. Файл с кодом стараться делать не более 2х экранов, лучше вместить в один. В папке должно быть не более десятка файлов, если их больше - задумайтесь о разбиении. Например, если у вас много reducer-ов в проекте и они в одной папке, можно выделить те, что используются в отдельных разделах сайта в каталоге этих разделов и подключать эти хранилища только когда они нужны. Область памяти человека не безгранична, поэтому такой код/проект/каталог будут более читаемы и их будет легко поддерживать.

#### Комментарии
Если вы используете хорошие, понятные названия переменных/файлов/функций/компонентов/props/названия_свойств_модели, то комментарии зачастую лишние и являются "вычисляемыми значениями". Но они необходимы в неочевидных местах, например в сложных регулярных выражениях, хитрых условиях и сложных алгоритмах. 

Также комментарии полезны в тех случаях, если у вас есть настройки автодокументирования и вы указываете типы данных. Но при использовании строгой типизации такие комментарии становятся значительно компактнее.
 
### Скорость работы
Основной антипаттерн – преждевременная оптимизация. Однако существуют базовые навыки, которые можно применять, основываясь на умозрительных заключениях, исходя из [временной сложности](https://ru.wikipedia.org/wiki/%D0%92%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C). Попросту говоря, учитывайте сколько элементов будет перебирать функция.

```javascript
// быстрее всех и не зависит от размера списка:
const a = {
  ...manyElements,
  test: 'test'
}
const result = a[test] //операция мгновенная, так как использует hash таблицу
```

```javascript
const a = [
  ...manyElements,
  { key: 'test', value: 'test' }
];

// быстро, но зависит от размера списка:
const result = a.find(item => item.key === 'test') //операция будет перебирать элементы пока не найдёт результат

// медленнее всех, так как перебирает все элементы списка
let result;
a.forEach(item => {
  if(item.key === 'test') {
    result = item;
  }
}) //операция будет последовательно перебирать каждый элемент
```
Исходя из примеров выше, вы можете принять решение сразу хранить объекты под уникальными ключами, чтобы находить элементы мгновенно. Если вам нужно искать по нескольким ключам, вы можете создать несколько объектов, с разными ключами, но хранить там объекты, которые будут лишь ссылками, поэтому это не займёт место. Для создания такого объекта из массива можно использовать функцию reduce:
```javascript
// быстрее всех и не зависит от размера списка:
const items = [
  {key: 'first', value: 'First'},
  {key: 'second', value: 'Second'}  
]
const distByKey = items
  .reduce((acc, item) => ({
    ...acc,
    [item.key]: item // хранение будет по ссылке, что практически не занимает память
  }), {})
const distByValue = items
  .reduce((acc, item) => ({
    ...acc,
    [item.value]: item // хранение будет по ссылке, что практически не занимает память
  }), {})
  
```

#### === 
Используйте строгое сравнение "===", вместо "==". Оно не приводит обе стороны условия к единому типу и не тратит на это времени и неявной магии, которую разработчик может сходу не увидеть.
```javascript
const a = 65;
const b = '65';
if (a == 'b') {
  // bad
}
if (a === parseInt(b, 10)) {
  // good
} 
```

#### if
Старайтесь минимизировать кол-во "if", тернарных операторов, "switch" и других операторов, приводящих к разветвлению программы. Читать код, изобилующий множеством условий, крайне сложно. Также старайтесь делать проверку в самом начале и делать return, вместо того чтобы писать длинный код внутри "if". Ну и фигурные скобки переносятся всегда, даже если внутри один лишь return.

```javascript
const good = arg => {
  if(!arg) {
    return;
  }
  // long code
  // ...
  // ...
  // ...
}

const bad = arg => {
  if(arg) {
   // long code
   // ...
   // ...
   // ...
  } 
}
``` 

#### Магические числа
Старайтесь не использовать в ваших функциях "захардкоженых предустановок". Все цифры и селекторы должны быть вынесены и передаваться аргументом или импортироваться из единого конфига. В том числе, если вы пишете функцию сложной сортировки, вы можете аргументом передавать не имя поля, а функцию, по которой достаётся значение:

```javascript
const sorting = (items, fn) => R.sort(fn, items)
// вместо :
const sorting = (items, name) => R.sort((a, b) => (a[name] > b[name] ? -1 : 1), items)
```

#### Используйте debug в браузере, а не console.log
В chrome вы можете зайти в developer tools, открыть "sources", там нажать cmd+P (ctrl+p) и набрать имя файла с вашим кодом (потому и удобно разбивать код на множество мелких файлов). Там вы можете поставить debug точку остановки, в том числе по правой клавише на ней установить условие остановки. Когда код дойдёт до этого места, вы сможете посмотреть не только конкретную переменную, но и все переменные окружения. Так вы не потратите время компиляции. Приучайте себя, сначала сложно привыкнуть, потом втянитесь. Отладка - это 70% времени разработки. Уменьшайте это время умелым дебагом, тестированием и наличием storybook.

### Совместимость с браузерами
При разработке необходимо учитывать совместимость js методов с версиями браузеров или сервера, где этот код будет запускаться. Как правило, для проверки совместимости используют [caniuse.com](http://caniuse.com). А для поддержки функций, которые вам необходимы, но не поддерживаются всеми версиями браузеров, лучше не засорять код условиями, а использовать различные shim решения, которые при использовании функции проверяют её существование и добавляют совместимый код функции, если её нет. Бывают комплексные решения, такие как [modernizr](https://modernizr.com/).

Особое внимание уделяйте совместимости при использовании "фреймворка" [vanilla js](http://vanilla-js.com/).

### Тестирование
Используйте [TDD](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) при разработке любых функций, даже самых простых. Так скорость разработки только вырастает, так как вы не тратите время на многократный запуск приложения для отладки, а также проверяете все виды входных данных одновременно. Плюс можете рефакторить приложение, меняя код функции, не "прокликивая" функции, а запуская тесты. Причём тесты можно запускать в различных браузерах, что поможет отладить совместимость с браузерами. Для тестирования используют самые разные инструменты, что будет темой отдельных статей.

Интеграционное UI-тестирование - это когда тест сам прокликивает все формы, кнопки, авторизуется и так далее. Оптимально поддерживать могут только специально выделенные тестировщики. Разработчик, который увлекается подобным тестированием, попадает в западню поддержки этих тестов при постоянно изменяемом UI. Разработчик может писать Unit-тесты, а также UI тестирование отдельных компонентов. В современных react компонентах это делать довольно несложно.

### Сторибук (ui-kit) 
При разработке и тестировании, в том числе pixel perfect, удобно использовать автоматически генерируемую [storybook](https://github.com/storybooks/react-storybook) библиотеку ваших разрабатываемых компонентов. Использование storybook позволяет быстрее разрабатывать компоненты и гарантировать им изолированность от данных остальной страницы. Также, вы в любой момент можете проверить все состояния и виды компонентов. Это удобно и для тестировщиков и для ваших коллег разработчиков. Это своеобразное оглавление вашего проекта, где можно ознакомиться со всеми компонентами и избавить себя от "забывчивости в переиспользовании" компонентов.

Ну и учтите, что компонент открывается один, изолированно, и поэтому компиляция и отрисовка ваших изменений (кода и стилей) происходит гораздо быстрее, чем если вы разрабатываете компонент прямо на странице с "соседями" и реальными запросами к базе данных. Данные компоненту предоставляются "фейковые", поэтому всё по умолчанию работает без асинхронных операций.

### Именования функций, переменных, имён файлов и директорий
В js используется camelCase. В API запросах к серверу традиционно используется snake_case, хотя Google в последнее время и там переходит на использование camelCase. Если в названии вашей функции есть слово "And", значит она выполняет больше одной функции. Тип данных обозначать в названии переменных не следует. Префиксы, bem стиль именования стоит исключить, если вы используете модульный подход.

При именовании старайтесь анализировать так: если удалю это слово из названия, легко ли понять, что означает эта переменная без комментариев и излишних затрат "мыслетоплива".

### Копипаст
Запретите себе использование "копипаста". Это когда одинаковый по сути код повторяется по проекту многократно. Используйте в таких случаях композицию, которая заключается лишь в создании отдельного файла с отдельной функцией. Затраты времени (а они смешные при использовании snippets и автодополнении) вознаградятся экономией на отладке. Основная проблема "копипаста", которую не видят новички, в том, что скопированный многократно код с ошибкой будет, при найденом баге, исправлен лишь в одном месте (разработчик не найдёт другие, если не он писал код) и приложение пройдёт новый виток "круга ада тестирования". Гораздо проще выделить функцию в отдельный файл, создать тест, протестировать пару примеров использования и импортировать функцию из этого каталога.

### Генератор компонентов
Одним из подвидом "копипаста" является копирование из раза в раз компонентов и заготовок функций. Если это сложный процесс, нужно много прокликивать, подписывать, переименовывать, вспоминать все базовые библиотеки, которые нужно импортировать – то "подсознательно" разбивать большой компонент на подкомпоненты вам будет "неохота". Как в известном мультике: "Лучше день потерять, чтобы научиться летать, а потом за час долететь, чем целый день идти".

Для простых случаев вы можете использовать snippets, где можно использовать пользовательские имена, которые сами вставятся куда нужно при генерации сниппета. У сниппетов один большой недостаток – каждый разработчик их пишет сам.

Но более сложные сущности лучше генерировать при помощи генераторов. Тут вам поможет yeoman, npm скрипт или то, что используем мы в React проектах: "[Redux-cli](https://github.com/SpencerCDixon/redux-cli)"

### DOM операции, частое обновление
Те, кто начинал с jQuery или использует Vanilla js, зачастую не задумываются о миллисекундах, которые тратятся не только на операции изменения DOM-дерева, но и даже на операции чтения. В фреймворках React, Angular и некоторых других, используется виртуальный DOM, операции с которым дешевле(быстрее).

Но самый оптимальный подход - использовать однонаправленный поток данных, когда у вас есть объекты и массивы данных и на их основе отрисовывается DOM-дерево. Фреймворк(или ваш код) отвечает за перенос этих данных в реальный DOM и делает это не по "кусочкам", а одним разом, вспоминая предыдущее и текущее состояние и вычислив, что нужно изменить.

В операциях с DOM есть свои антипаттерны, часть из них описана [тут](http://agentcooper.ghost.io/javascript-anti-patterns/). Особенно будьте осторожны с анимацией(старайтесь использовать CSS, SVG анимацию вместо js), скроллингом (старайтесь использовать vanilla-js), используйте debounce или throttle функции пользовательского ввода.

### Гонки (мерцание контактов)
Не забывайте дизейблить кнопки отправки форм во время отправки. Учитывайте возможность двойного асинхронного запроса данных и заранее вносите в код учёт двойных кликов.
