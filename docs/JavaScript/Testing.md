# Тестирование

Основная цель тестов — убедиться, что конечный продукт или какая-то его часть работают корректно. Помимо этого есть и другая польза:

- Тесты выступают как документация. Если на какой-то случай есть тест,
  значит поведение точно должно быть таким.
  Например, если у функции деления при делении на ноль есть два варианта
  работы: бросить исключение или вернуть бесконечность. Если теста нет,
  то непонятно текущее поведение задумывалось или его просто забыли учесть.
- Тесты упрощают рефакторинг — на текущий функционал уже написаны тесты,
  а значит можно изменять внутреннюю реализацию, не боясь что-то сломать.
- Во многих случаях тесты ускоряют (а не замедляют!) написание кода.
  Причина в том, что во время написания кода нет необходимости
  вручную проверять все возможные кейсы работы, чтобы убедиться,
  что всё работает корректно.

## Unit-тесты

Unit-тесты - это тесты, которые тестируют какой-то
один изолированный модуль — например, функцию или класс.

Наиболее легкотестируемыми являются чистые функции — функции,
которые не имеют сайд-эффектов, получают всё необходимое в своих аргументах и возвращают результат
каких-либо вычислений.

Основные преимущества в том, что такие функции не требуют для себя
какого-либо cпецифичного окружения — например, браузера.
А значит, что такие тесты проще запускать, и, так как внутри выполняются 
только вычисления, тест проходит быстро.

Сам юнит-тест представляет собой вызов функции и проверку на то,
что функция вернула какое-то определенное значение. Иными словами,
юнит-тест — это простое сравнение результата с каким-либо эталоном.

```javascript
it('sums numbers', async () => {
  expect(sum(2, 5)).toEqual(7)
})
```

Проверять необходимо пограничные случаи, желательное и нежелательное поведение.

Например, для функции сложения это будут варианты:
- сложение положительных чисел;
- сложение с нулем;
- сложение отрицательных чисел;
- сложение дробных чисел.

Не стоит стремиться написать тесты на все возможные случаи. Если вы не протестируете кейс, который воспроизводится в одном случае на миллион, то просто сделаете это, когда баг будет найдет. Конечно же, если вы пишите медицинскую или финансовую систему, то стоит постараться исключить и такие баги, но так или иначе все проблемные места вы предсказать не сможете.

Очень важно, как вы пишите тесты. Всегда придерживайтесь правила AAA (или 3A): Arrange, Act, Assert. Каждый ваш тест должен быть визуально разделен на три этапа:

```javascript
it('calculates intersection of two vectors', async () => {
  // Arrange
  const vect1 = [...]
  const vect2 = [...]
  
  // Act
  const result = areVectorsIntersect(vect1, vect2)
  
  // Assert
  expect(result).toBeTrue()
})
```

Конечно, не всегда эти стадии стоит явно выделять в тесте. Если Arrange и Act являются крайне простыми, как в случае с тестом функции `sum`, то можно все три стадии записать в одной строке, в ином же случае стоит добавлять пробельную строку между ними для визуального выделения стадий.

Не выполняйте разные проверки в одном тесте:

```javascript
// плохо
it('sums two numbers', async () => {
  expect(sum(10, 20)).toBe(30)
  expect(sum(-10, -20)).toBe(-30)
  expect(sum(-10, 20)).toBe(10)
  expect(sum(10, 20)).not.toBe(42)
})

// хорошо
it('sums two positive numbers', async () => {
  expect(sum(10, 20)).toBe(30)
})

it('sums two negative numbers', async () => {
  expect(sum(-10, -20)).toBe(-30)
})

it('sums a positive and a negative number', async () => {
  expect(sum(-10, 20)).toBe(10)
})
```

Если в одном из кейсов будет ошибка, то тест, проверяющий все сразу упадет, и не будет понятно, где именно случилась ошибка. Кроме того, бывают случаи, когда бизнес логика меняется и тесты необходимо менять/удалять. В случае с кучей проверок в одном тесте это может быть более проблематично, чем если бы мы делали это для отдельных тестов.

Старайтесь, чтобы описание вашего теста явно отражало, что именно вы проверяете, если ваша функция должна складывать числа, а вы проверяете что она корректно складывает отрицательное и положительное число, то напишите так: `it('sums negative and positive numbers', () => { ... })`, - при этом функция `it` должна начинать ваше описание так, чтобы получилась нормальная фраза на английском языке: `it sums negative and positive numbers`.

Не используйте слово *should* в описании теста. Оно не описывает то, что делает ваша функция, оно повторяется из теста в тест, что делает его ненужным для описания теста.

```javascript
// плохо
it('should sum two positive numbers', async () => {
  expect(sum(10, 20)).toBe(30)
})

// хорошо
it('sums two positive numbers', async () => {
  expect(sum(10, 20)).toBe(30)
})
```

Таким образом вы избавляетесь от повторяющегося и неважного слова *should*, оставляя только важную часть описания.

Используйте `describe` не только для выделения того юнита, который вы тестируете, но и для выделения контекста тестирования. Допустим у нас есть некий компонент `Block`, он может находиться в двух состояниях: видимый и невидимый. Когда наш компонент видим, то он ведет себя одним образом, когда невидим - другим. Мы хотим проверить этом, для этого напишем несколько тестов:

```javascript
describe('Block', () => {
  describe('when it is visible', () => {
    it('shows something', () => {})
    it('calculates own position', () => {})
  })
  
  describe('when it is invisible', () => {
    it('hides something', () => {})
    it('does not calculate own position', () => {})
  })
})
```

Таким образом наши проверки будут выполняться в двух явных контекстах:

```
Block
  when it is visible
    shows something
    calculates own position
  when it is invisible
    hides something
    does not calculate own position
```

Это позволяет избавиться от дублирования в описаниях тестов. Без объединения в блок контекста мы бы написали так:

```javascript
// плохо
describe('Block', () => {
  it('when it visible it shows something', () => {})
  it('when it visible it calculates own position', () => {})
  it('when it invisible it hides something', () => {})
  it('when it invisible it does not calculate own position', () => {})
})
```

Тесты с блоками контекста проще читаются, легче найти нужный тест, а так же понять какой тест и при каких условиях упал.

## Code Coverage

Покрытие кода — это метрика, которая показывает какое количество
кода было протестировано.
Покрытие может вычисляется по-разному:
- покрытие операторов — каждая ли строчка выполнилась;
- покрытие условий — каждая ли ветка функции была выполнена;
- покрытие функций — каждая ли функция вызывалась.

100% покрытие кода не гарантирует того, что модуль работает корректно.
Для покрытия линейной функции достаточно одного теста — все операторы
выполняться в этом тесте. Но, если внутри есть деление на аргумент функции,
то потенциально возможно деление на ноль и тест не проверяет,
что деление на ноль корректно обрабатывает.

## TDD
TDD — техника разработки, в которой сначала пишутся тесты, а затем
функция. Тесты пишутся только на какую-то небольшую часть функционала.

В целом процесс разработки выглядит так:
1. написать тесты для какой-либо части функционала;
2. запустить тесты и убедиться, что тесты не проходят — необходимо убедиться,
  что тесты корректные (а не проходят всегда);
3. написать код для функционала, чтобы код проходил тесты, при этом
  код не должен быть идеален, он должен просто проходить тесты;
4. проверить, что проходят все тесты;
5. отрефакторить код;
6. вернуться к первому шагу.
